/* Class = "NSComboBox"; ibShadowedToolTip = "<key>Inject</key>\n<string>Detect</string>\nProperty injection for the sound chip. Only works when the DSDT defines Device (HDEF). If you renamed it, you can also inject the other properties differently. Do not use this parameter with VoodooHDA. Possible options are:\n\nNo - Injection is turned off\nDetect - Automatic detection of the sound chip and injection of its ID as layout ID. Actually this is nonsense but still very popular. Does not do any harm and affects the display of sound properties in System Profiler.\n883 - Decimal number representing. Refers to Realtek ALC883 in this case.\n0x373 - Same as above in hexadecimal.\nThese numbers are incorrect, you will need to find the correct value and possibly replace the layout file bundled with AppleHDA to get the chip working."; ObjectID = "0Ex-U9-H5a"; */
"0Ex-U9-H5a.ibShadowedToolTip" = "<key>Inject</key>
<string>Detect</string>
사운드 칩셋 인식 을위한 속성 인젝션. DSDT가 장치 (HDEF)를 정의 할 때만 작동합니다 이름을 변경 한 경우 다른 속성을 다르게 인젝션 할 수도 있습니다 이 매개 변수를 VoodooHDA와 함께 사용하지 마십시오 사용 가능한 옵션은 다음과 같습니다

아니요 - 인젝션 비활성화
Detect - 사운드 칩셋 자동 감지 및 장치 ID및 레이아웃 ID 인젝션 사실 이것은 말도 안되지만 여전히 많이 사용됩니다 시스템 정보 보기의 사운드 속성 표시에 영향을 미치지 않으며 영향을 미치지 않습니다
883 - 10 진수를 나타냅니다. 이 경우 Realtek ALC883의 인젝션 방법에 대해 참고해 주세요.
0x373 - 위의 16 진수와 동일합니다
이 숫자가 틀리면 올바른 값을 찾아 AppleHDA에 번들 된 레이아웃 파일을 대체하여 칩을 작동 시켜야 합니다";

/* Class = "NSButton"; ibShadowedToolTip = "<key>FixOwnership</key>\n<true/>\nIt is possible to leave USB injection enabled and only turn off the ownership fix.\n\nThis fix is not relevant for UEFI booting."; ObjectID = "2I2-ep-g7I"; */
"2I2-ep-g7I.ibShadowedToolTip" = "<key>FixOwnership</key>
<true/>

USB 인젝션을 사용 가능 상태로 유지하고 소유권 수정 사항 만 비활성화 하는 것이 가능합니다

이 수정은 UEFI 부팅과 관련이 없습니다";

/* Class = "NSButton"; ibShadowedToolTip = "<key>ResetHDA</key>\n<true/>\nAudio controller initialization. Some users have non-working sound after cold boot but works after restart or wake (even on Windows!). This is a workaround that works at early boot, so it will affect Windows as well."; ObjectID = "4ga-hk-hZY"; */
"4ga-hk-hZY.ibShadowedToolTip" = "<key>ResetHDA</key>
<true/>
오디오 컨트롤러 초기화 일부 사용자는 콜드 부팅 후 작동하지 않는 사운드를 가지고 있지만 다시 시작하거나 깨우면 작동합니다 (윈도즈에서도 말이죠!) 이는 초기 부팅 시 작동하는 해결 방법이므로 윈도즈에도 영향을 미칩니다";

/* Class = "NSTableColumn"; headerCell.title = "Key*"; ObjectID = "5Yq-DI-Ikq"; */
//"5Yq-DI-Ikq.headerCell.title" = "키*";

/* Class = "CocoaBindingsConnection"; ibShadowedIsNilPlaceholder = "HEX in DATA type; 0 = \"NO\", 1 = \"YES\" in BOOLEAN type "; ObjectID = "8r1-Ie-cZD"; */
"8r1-Ie-cZD.ibShadowedIsNilPlaceholder" = "데이터 유형의 16진수 0 = “아니오”, 1 = “예” 부울 유형";

/* Class = "NSButton"; ibShadowedToolTip = "Some tuning about C4/C6 States and SpeedStep"; ObjectID = "9QK-wm-bPF"; */
"9QK-wm-bPF.ibShadowedToolTip" = "C4 / C6 스탯과 스피드스텝에 관한 튜닝";

/* Class = "NSTableColumn"; headerCell.title = "Value Type"; ObjectID = "E6H-GQ-ELu"; */
"E6H-GQ-ELu.headerCell.title" = "값 유형";

/* Class = "NSButton"; ibShadowedToolTip = "<key>Inject</key>\n<true/>\nInjects USB properties. You can turn it off for whatever reason, if you need. It is also disabled if the DSDT patch mask matches 0x1000 to prevent data duplication."; ObjectID = "Eq8-eZ-fBy"; */
"Eq8-eZ-fBy.ibShadowedToolTip" = "<key>Inject</key>
<true/>
USB 속성을 주입합니다 필요한 경우 어떤 이유로 든 해제 할 수 있습니다 데이터 중복을 방지하기 위해 DSDT 패치 마스크가 0x1000과 일치하는 경우에도 비활성화됩니다";

/* Class = "NSButton"; ibShadowedToolTip = "<key>NoDefaultProperties</key>\n<false/>\nThis key will affect DSDT fixes and force them to generate an empty _DSM. For example, if you enable FIX_DISPLAY Clover will create a device for the graphics card but with an empty _DSM. AddProperties and FakeID values will still be injected.\n\nThis works only for Display, Sound, LAN and WiFi."; ObjectID = "Fbo-vD-sOq"; */
"Fbo-vD-sOq.ibShadowedToolTip" = "<key>NoDefaultProperties</key>
<false/>
이 키는 DSDT 수정 사항에 영향을 미치고 빈 _DSM을 생성하도록합니다 예를 들어, FIX_DISPLAY를 활성화하면 클로버가 빈 _DSM이있는 그래픽 카드 용 장치를 만듭니다 AddProperties 및 FakeID 값은 계속 주입됩니다

디스플레이, 사운드, LAN 및 WiFi에서만 작동합니다";

/* Class = "NSButton"; ibShadowedToolTip = "<key>HighCurrent</key>\n<true/>\nMore power needed to charge iPad from USB ports."; ObjectID = "H9i-56-9Ga"; */
"H9i-56-9Ga.ibShadowedToolTip" = "<key>HighCurrent</key>
<true/>

USB 포트에서 iPad를 충전 하는데 있어 더 많은 전력이 필요할 때 사용합니다";

/* Class = "NSView"; ibShadowedToolTip = "Now Devices->Properties can be written into config.plist in format as DarwinDumper do\n\nFor example\n<dict>\n<key>PciRoot(0x0)/Pci(0x1b,0x0)</key>\n\t<dict>\n\t\t<key>MaximumBootBeepVolume</key>\n\t\t<string>M</string>\n\t\t<key>PinConfigurations</key>\n\t\t<data>\n\t\tUEArAUABEJBCARCQIDCLARABoJAw4MsBYOBLAQ==\n\t\t</data>\n\t\t<key>layout-id</key>\n\t\t<data>\n\t\tEgAAAA==\n\t\t</data>\n\t\t<key>platformFamily</key>\n\t\t<data>\n\t\tAA==\n\t\t</data>\n\t</dict>\n\t<key>PciRoot(0x0)/Pci(0x1c,0x2)/Pci(0x0,0x0)/Pci(0x0,0x0)</key>\n\t<dict>\n\t\t<key>fwswappedbib</key>\n\t\t<data>\n\t\tAQAAAA==\n\t\t</data>\n\t</dict>\n\nThis way we can deprecate Arbitrary section."; ObjectID = "HE5-9l-mik"; */
"HE5-9l-mik.ibShadowedToolTip" = "이제 장치 > 속성을 다윈덤퍼 형식으로 config.plist에 쓸 수 있습니다

예를 들자면
<dict>
<key>PciRoot(0x0)/Pci(0x1b,0x0)</key>
	<dict>
		<key>MaximumBootBeepVolume</key>
		<string>M</string>
		<key>PinConfigurations</key>
		<data>
		UEArAUABEJBCARCQIDCLARABoJAw4MsBYOBLAQ==
		</data>
		<key>layout-id</key>
		<data>
		EgAAAA==
		</data>
		<key>platformFamily</key>
		<data>
		AA==
		</data>
	</dict>
	<key>PciRoot(0x0)/Pci(0x1c,0x2)/Pci(0x0,0x0)/Pci(0x0,0x0)</key>
	<dict>
		<key>fwswappedbib</key>
		<data>
		AQAAAA==
		</data>
	</dict>

이렇게 하면 임의 섹션이 비활성화 됩니다";

/* Class = "NSButton"; ibShadowedToolTip = "Try to force enable HPET if isn't."; ObjectID = "Hfo-IB-7nr"; */
"Hfo-IB-7nr.ibShadowedToolTip" = "그렇지 않을 경우 HPET를 강제 실행해 주세요";

/* Class = "NSButton"; ibShadowedToolTip = "<key>Inject</key>\n<false/>\nEnabling it will cause the automatic injection to turn off and allow the injection of a custom string from Properties"; ObjectID = "HY8-2T-aia"; */
"HY8-2T-aia.ibShadowedToolTip" = "<key>Inject</key>
<false/>
이 기능을 켜면 자동 인젝션 기능이 비활성화 되고 속성에서 사용자 정의 문자열을 인젝션 할 수 있습니다";

/* Class = "NSTableColumn"; headerCell.title = "Value Type"; ObjectID = "Jke-Be-RCo"; */
"Jke-Be-RCo.headerCell.title" = "값 유형";

/* Class = "NSTableColumn"; headerCell.title = "Value Type"; ObjectID = "pxi-J0-2Fb"; */
"pxi-J0-2Fb.headerCell.title" = "값 유형";

/* Class = "NSButton"; ibShadowedToolTip = "Enable or disable HDMI injection, disabled by default."; ObjectID = "Mi8-oT-4ye"; */
"Mi8-oT-4ye.ibShadowedToolTip" = "HDMI 인젝션을 활성화 또는 비활성화 합니다 (기본 값은 비활성화입니다)";

/* Class = "NSTableView"; ibShadowedToolTip = "<key>AddProperties</key>\n<array>\n  <dict>\n    <key>Device</key>\n    <string>NVidia</string>\n    <key>Key</key>\n    <string>AAPL,HasPanel</string>\n    <key>Value</key>\n    <data>AQAAAA==</data>\n  </dict>\n  <dict>\n    <key>Device</key>\n    <string>NVidia</string>\n    <key>Key</key>\n    <string>AAPL,Haslid</string>\n    <key>Value</key>\n    <data>AQAAAA==</data>\n    </dict>\n</array>\nUsing device properties injection may be insufficient for some cases (new device, new standard, new OS), so this function lets you customize these injected properties.\n\nYou may write as many properties as you want for these devices: * ATI * NVidia * IntelGFX * LAN * WIFI * Firewire * SATA * IDE * HDA * HDMI * LPC * SmBUS * USB"; ObjectID = "Ob7-UX-r0p"; */
"Ob7-UX-r0p.ibShadowedToolTip" = "<key>AddProperties</key>
<array>
  <dict>
    <key>Device</key>
    <string>NVidia</string>
    <key>Key</key>
    <string>AAPL,HasPanel</string>
    <key>Value</key>
    <data>AQAAAA==</data>
  </dict>
  <dict>
    <key>Device</key>
    <string>NVidia</string>
    <key>Key</key>
    <string>AAPL,Haslid</string>
    <key>Value</key>
    <data>AQAAAA==</data>
    </dict>
</array>
장치 속성 인젝션을 사용하면 일부 경우 (새 장치, 새 표준, 새 OS)에 불충분 할 수 있으므로이 함수를 사용하여 인젝션된 속성을 사용자 지정할 수 있습니다

* ATI * NVidia * IntelGFX * LAN * WIFI * Firewire * SATA * IDE * HDA * HDMI * LPC * SmBUS * USB";

/* Class = "NSTextField"; ibShadowedToolTip = "Replace Airport device name inside your DSDT"; ObjectID = "PQZ-Qh-lD1"; */
"PQZ-Qh-lD1.ibShadowedToolTip" = "DSDT 내부에서 Airport 장치 이름 변경";

/* Class = "NSView"; ibShadowedToolTip = "First you should look your boot.log or preboot.log (obtained by press F2 in Clover GUI). There is a list of your PCI devices.\n\n4:432 0:000 PCI (00|02:05.00) : 10EC 8167 class=020000\n\nThis is LAN device\n\nVendorID= 10EC - this is Realtek\n\nDeviceID= 8167 - This is Realtek 8167/8169/8110 Gigabyte Ethernet Controller\n\nIt is located on the PCI bus (green digits)\n\nBus = 02\n\nDevice = 05 \n\nFunction = 00\n\nThis location will be unique for every device in your computer. You may have two equal graphics cards with the same IDs and same model. But their locations will be different.\n\nWe have to write into config.plist in section \"Devices\", array \"Arbitrary\" of items one per device you want to inject properties.\n\n\t<key>Devices</key>\n\t<dict>\n\t\t<key>Arbitrary</key>\n\t\t<array>\n\t\t\t<dict>\n\t\t\t\t<key>PciAddr</key>\n\t\t\t\t<string>02:05.00</string>\n\t\t\t\t<key>Comment</key>\n\t\t\t\t<string>Realtek LAN 8167</string>\n\t\t\t\t<key>CustomProperties</key>\n\t\t\t\t<array>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>Key</key>\n\t\t\t\t\t\t<string>model</string>\n\t\t\t\t\t\t<key>Value</key>\n\t\t\t\t\t\t<string>Realtek 8169 Gigabit Ethernet Controller</string>\n\t\t\t\t\t</dict>\n\t\t\t\t\t<dict>\n\t\t\t\t\t\t<key>Key</key>\n\t\t\t\t\t\t<string>built-in</string>\n\t\t\t\t\t\t<key>Value</key>\n\t\t\t\t\t\t<data>AQAAAA==</data>\n\t\t\t\t\t</dict>\n\t\t\t\t</array>\n\t\t\t</dict>\n\t\t</array>"; ObjectID = "Qxp-DC-Voo"; */
"Qxp-DC-Voo.ibShadowedToolTip" = "먼저 boot.log 또는 preboot.log (클로버 GUI에서 F2를 눌러 얻음)를 확인해야합니다. PCI 장치 목록이 있습니다.

4 : 432 0 : 000 PCI (00 | 02 : 05.00) : 10EC 8167 class = 020000
이것은 LAN 장치입니다.

VendorID = 10EC - 리얼텍 입니다
DeviceID = 8167 - 리얼텍 8167/8169/8110 기가비트 이더넷 컨트롤러입니다
PCI 버스 (녹색 숫자)
Bus= 02
Device = 05
Funtion = 00

이 위치는 컴퓨터의 모든 장치마다 고유 값을 가지고 있습니다 동일 ID 및 동일한 모델을 가진 두 개의 동일한 그래픽 카드가 있을 수 있습니다 그러나 그들의 위치는 다릅니다
우리는 “장치”섹션에서 config.plist에 작성해야하며, 속성을 주입 할 장치 당 하나의 항목을 “임의로” 배열해 주세요

t<key>Devices</key>
	<dict>
		<key>Arbitrary</key>
		<array>
			<dict>
				<key>PciAddr</key>
				<string>02:05.00</string>
				<key>Comment</key>
				<string>Realtek LAN 8167</string>
				<key>CustomProperties</key>
				<array>
					<dict>
						<key>Key</key>
						<string>model</string>
						<key>Value</key>
						<string>Realtek 8169 Gigabit Ethernet Controller</string>
					</dict>
					<dict>
						<key>Key</key>
						<string>built-in</string>
						<key>Value</key>
						<data>AQAAAA==</data>
					</dict>
				</array>
			</dict>
		</array>";

/* Class = "NSTableColumn"; headerCell.title = "Value*"; ObjectID = "Txa-kI-pAD"; */
//"Txa-kI-pAD.headerCell.title" = "값*";

/* Class = "NSTextField"; ibShadowedToolTip = "<key>Properties</key>\n<string>0207364862FA54HG345</string>\nTo create your own string you need the tool gfxutil that, for example, is bundled with DarwinDumper. You will need to create an xml file using a device path in standard notation as header and list properties, which will be injected. The example shows a file used to enable a video card:\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>PciRoot(0x0)/Pci(0x2,0x0)</key>\n    <dict>\n        <key>AAPL,HasPanel</key>\n        <data>AQAAAA== </data>\n        <key>built-in</key>\n        <data>AA==</data>\n        <key>class-code</key>\n        <data>AAADAA==</data>\n        <key>device_type</key>\n        <data>ZGlzcGxheQA=</data>\n        <key>model</key>\n        <data>R01BIDk1MAA=</data>\n    </dict>\n</dict>\n</plist>\nIt is possible to obtain the currently used plist with DarwinDumper, to modify it and convert it into string form with the command:\n\n./gfxutil –i xml –o hex devprop.plist devprop.hex\n.. resulting in:\n\nd30000000100000001000000c70000000500000002010c00d041030a000000000101060000027fff0400100000006d006f00640065006c0000000c000000474d4120393530001c0000006400650076006900630065005f00740079007000650000000c000000646973706c617900200000004100410050004c002c00480061007300500061006e0065006c0000000800000001000000160000006200750069006c0074002d0069006e00000005000000001a00000063006c006100730073002d0063006f006400650000000800000000000300\nThe result needs to be used as a value for DeviceProperties. The same effect can be achieved by adding a _DMS method into the according section of your DSDT. It may be practical to use the string method when no DSDT is available yet."; ObjectID = "UDA-0b-dPf"; */
"UDA-0b-dPf.ibShadowedToolTip" = "<key>Properties</key>
<string>0207364862FA54HG345</string>
자신 만의 문자열을 만들려면, 예를 들어 다윈덤퍼와 번들로 묶인 gfxutil 도구가 필요합니다 인젝션 시킬 헤더 및 목록 특성으로 표준 표기법의 장치 경로를 사용하여 xml 파일을 작성해야합니다 이 예제는 비디오 카드를 활성화하는 데 사용되는 파일을 보여줍니다

<?xml version=“1.0” encoding=“UTF-8”?>
<!DOCTYPE plist PUBLIC “-//Apple//DTD PLIST 1.0//EN” “http://www.apple.com/DTDs/PropertyList-1.0.dtd”>
<plist version=“1.0”>
<dict>
    <key>PciRoot(0x0)/Pci(0x2,0x0)</key>
    <dict>
        <key>AAPL,HasPanel</key>
        <data>AQAAAA== </data>
        <key>built-in</key>
        <data>AA==</data>
        <key>class-code</key>
        <data>AAADAA==</data>
        <key>device_type</key>
        <data>ZGlzcGxheQA=</data>
        <key>model</key>
        <data>R01BIDk1MAA=</data>
    </dict>
</dict>
</plist>
다윈덤퍼를 사용하여 현재 사용중인 plist를 가져 와서 수정하고 다음 명령을 사용하여 문자열 형식으로 변환 할 수 있습니다

./gfxutil –i xml –o hex devprop.plist devprop.hex
.. resulting in:

d30000000100000001000000c70000000500000002010c00d041030a000000000101060000027fff0400100000006d006f00640065006c0000000c000000474d4120393530001c0000006400650076006900630065005f00740079007000650000000c000000646973706c617900200000004100410050004c002c00480061007300500061006e0065006c0000000800000001000000160000006200750069006c0074002d0069006e00000005000000001a00000063006c006100730073002d0063006f006400650000000800000000000300

결과는 장치 속성 값으로 사용해야 합니다 DSDT의 해당 섹션에 _DMS 메소드를 추가하여 동일한 효과를 얻을 수 있습니다 아직 DSDT를 사용할 수없는 경우 문자열 메소드를 사용하는 것이 실용적 일 수 있습니다";

