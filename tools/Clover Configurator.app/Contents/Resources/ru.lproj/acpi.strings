/* Class = "NSTableColumn"; headerCell.title = "String[TableId]/Number[Length]"; ObjectID = "2TV-zh-dka"; */
"2TV-zh-dka.headerCell.title" = "строка[TableId]/число[Length]";

/* Class = "NSTableColumn"; headerToolTip = "String[TableId]/Number[Length]"; ObjectID = "2TV-zh-dka"; */
"2TV-zh-dka.headerToolTip" = "строка[TableId]/число[Length]";

/* Class = "NSButton"; ibShadowedToolTip = "<key>DropOem</key>\n<true/>\nDrops all internal SSDT tables to avoid conflicts when generating an SSDT for your processor, which contains P- and C-States. Clover can do this automatically or you can specify an external file, which will be loaded from EFI/OEM/[model]/ACPI/patched."; ObjectID = "3OB-Qg-u2B"; */
"3OB-Qg-u2B.ibShadowedToolTip" = "<key>DropOem</key><true/>Отбрасывает все встроенные SSDT таблицы, чтобы избежать конфликта с созданными SSDT для Вашего процессора, который содержит C-States и P-States. Clover может делать это автоматически или Вы можете указать свой файл, который будет загружен из папки EFI/OEM/[model]/ACPI/patched.";

/* Class = "NSButton"; ibShadowedToolTip = "Renames device AC0 to ADP1."; ObjectID = "4L0-lZ-ZbZ"; */
"4L0-lZ-ZbZ.ibShadowedToolTip" = "Переименовывает устройство AC0 в ADP1";

/* Class = "NSButton"; ibShadowedToolTip = "This device is used for IntelHDxxxx graphics. \nThis is required when using the FakeID->IMEI bit. \nIt does nothing on Core 2 systems."; ObjectID = "5cK-Vm-6vG"; */
"5cK-Vm-6vG.ibShadowedToolTip" = "Это устройство используется для видеокарт Intel HD. Требуется при использовании подмены ID -> IMEI. Не работает на системах с Core 2";

/* Class = "NSButton"; ibShadowedToolTip = "Provide a set of corrections to DSDT to make your system \"Darwin\"\nto be identified as \"Windows 2001\", like most ACPI systems. \nMore ACPI devices will work in this mode."; ObjectID = "7fD-EQ-f6e"; */
"7fD-EQ-f6e.ibShadowedToolTip" = "Мимикрия ОС Дарвин под систему Windows XP. Многие проблемы со сном и с яркостью растут ногами из неверной идентификации системы.";

/* Class = "NSButton"; ibShadowedToolTip = "<key>SlpSmiAtWake</key>\n<true>\nIt adds SLP_SMI_EN=0 at every wake. It may help solve sleep and shutdown issues on UEFI boot."; ObjectID = "7Md-lK-CZ9"; */
"7Md-lK-CZ9.ibShadowedToolTip" = "Добавляет SLP_SMI_EN=0 при каждом пробуждении. Это может помочь решить проблемы со сном и выключением при UEFI загрузке";

/* Class = "NSButton"; ibShadowedToolTip = "Inserts plugin-type One to CpuPm SSDT"; ObjectID = "07p-TL-NPT"; */
"07p-TL-NPT.ibShadowedToolTip" = "Вставляет plugin-type=1 в CpuPm SSDT.";

/* Class = "NSButton"; ibShadowedToolTip = "Name ACST is used differently by Apple and ASUS. \nFor ASUS it's the AC adapter state, but for Apple it's\n a replacement for _CST, c-states table. \nTo avoid conflict it is necessary to rename such function to something else."; ObjectID = "9LT-be-eqr"; */
"9LT-be-eqr.ibShadowedToolTip" = "В некоторых DSDT встречается устройство, или метод, или переменная с именем ACST, но это имя используется MacOSX 10.8+ для управления c-state. Совершенно неявный конфликт с очень неясным поведением. Этот фикс переименовывает все вхождения такого имени в нечто безопасное.";

/* Class = "NSButton"; ibShadowedToolTip = "<key>SuspendOverride</key>\n<true>\nInfluences the DSDT patch FixShutdown_0004 and extends the fix from state 5 to 3, 4 and 5 (sleep and suspend)."; ObjectID = "82W-UW-8aK"; */
"82W-UW-8aK.ibShadowedToolTip" = "Патч шатдауна работает только на состояние типа 5 - shutdown, однако, мы можем захотеть распространить этот патч на состояния 3 и 4, ставим SuspendOverride = true.\nМне это помогло с заходом в сон при UEFI-загрузке. Иначе экран гас, а лампочки и вентиляторы продолжали работать.";

/* Class = "NSButton"; ibShadowedToolTip = "Only patches the \"Darwin OS\" identification."; ObjectID = "a85-0W-IoZ"; */
"a85-0W-IoZ.ibShadowedToolTip" = "Изменяет только идентификацию системы как Darwin OS";

/* Class = "NSButton"; ibShadowedToolTip = "Injects device and properties for the WiFi controller. \nAlso made FakeID for some known substitutions."; ObjectID = "Aib-Xz-XYs"; */
"Aib-Xz-XYs.ibShadowedToolTip" = "Инжектирует свойства для WiFi. Позволяет работать подмене ID.";

/* Class = "NSButton"; ibShadowedToolTip = "Excludes IRQ(0) from RTC device."; ObjectID = "AOU-P1-GqP"; */
"AOU-P1-GqP.ibShadowedToolTip" = "Исключает IRQ(0) из устройства RTC";

/* Class = "NSTableView"; ibShadowedToolTip = "Binary DSDT patching\n\n<key>Patches</key>\n  <array>\n    <dict>\n      <key>Find</key>\n      <data>W4IeQkFUMQhfSElEDEHQDAoIX1VJRAEUCF9TVEEApAA=</data>\n      <key>Replace</key>\n      <data></data>\n    </dict>\n    <dict>\n      <key>Find</key>\n      <data>UFhTWAhfQURSAAhfUFJXEgYC</data>\n      <key>Replace</key>\n      <data>UFhTWAhfQURSAAhfU1VOCgQIX1BSVxIGAg==</data>\n    </dict>\n  </array>"; ObjectID = "ar5-MC-CKJ"; */
"ar5-MC-CKJ.ibShadowedToolTip" = "Патч DSDT по типу Найти/Заменить.";

/* Class = "NSButton"; ibShadowedToolTip = "<key>Generate</key>\n<dict>\n  <key>PStates</key>\n  <true/>\n</dict>\nAutomatic SSDT table generation, which extends the processor section with _PPC, _PPC and _PSS methods.\n\n_PCT - Performance control. Controls SpeedStep functions\n_PPC - Performance Present Capabilities. SpeedStep capabilities. This method returns a value limiting the frequency. Look further for PLimitDict.\n_PSS - Performance Supported States. An array containing possible CPU states - P-States.\nPLimitDict, UnderVoltStep and Turbo will be taken into consideration when generated this array."; ObjectID = "bdA-kb-5za"; */
"bdA-kb-5za.ibShadowedToolTip" = "Автоматическая генерация таблицы SSDT c методами _PPC, и _PCT и _PSS. На генерацию влияют PLimitDict, UnderVoltStep и Turbo.";

/* Class = "NSButton"; ibShadowedToolTip = "Key UseSystemIO at SSDT section will serve to choose in the generated _CST tables between:\n\nRegister (FFixedHW,\nRegister (SystemIO,"; ObjectID = "cbd-3A-zqo"; */
"cbd-3A-zqo.ibShadowedToolTip" = "Использует UseSystemIO для выбора правильного метода генерации таблиц _CST между:  Register (FFixedHW,\n\
Register (SystemIO,";

/* Class = "NSButton"; ibShadowedToolTip = "This is a very functional patch for video devices. \nRecommended even if you don't want to inject properties to the device.\n When this bit is set other settings like FakeID will be applied as well."; ObjectID = "dff-je-gcc"; */
"dff-je-gcc.ibShadowedToolTip" = "Это очень функциональный патч, рекомендуется, даже если Вы не собираетесь инжектить параметры устройства. Позволяет работать подмене ID.";

/* Class = "NSTextField"; ibShadowedToolTip = "<key>MaxMultiplier</key>\n<integer>30</integer>\nIntroduces as an analogy to the minimal multiplier but not really necessary. It is not advised to set it."; ObjectID = "ecf-V5-wTF"; */
"ecf-V5-wTF.ibShadowedToolTip" = "Максимальный множитель процессора, не рекомендуется вводить значение.";

/* Class = "NSButton"; ibShadowedToolTip = "Helps enable SpeedStep on Ivy Bridge+ systems."; ObjectID = "fUT-Un-eDT"; */
"fUT-Un-eDT.ibShadowedToolTip" = "Помогает включить SpeedStep на IvyBridge и выше";

/* Class = "NSButton"; ibShadowedToolTip = "AutoMerge feature for merging/replacement of SSDTs (or other AMLs) by content in ACPI/patched\n \nBy setting config.plist/ACPI/AutoMerge=true (default is false to retain old behavior), content in ACPI/patched will attempt to be matched against native bits referred to by the XSDT.  Much like how DSDT.aml placed in ACPI/patched *replaces* native DSDT, you can use this feature to replace SSDTs (or other tables) automatically without using DropTables, or DropOem. More importantly, the relative order of the tables is retained.  It means you can replace only a single table without resorting to DropOem=true and SortedOrder (which implies placing all SSDTs in ACPI/patched). \n \nThe matching is based on file name and OemTableID/signature.\n \nFor SSDTs, the number in the file name is used to find the index in XSDT.  So, a file named SSDT-5.aml in ACPI/patched will replace the 6th SSDT in XSDT (because SSDTs extracted start at SSDT-0.aml).  Additional checking is done with regard to the OEM table ID, to avoid obvious mistakes (eg. placing an SSDT-x.aml that is not a patched SSDT, or mixing up the naming/numbering of the SSDTs in ACPI/patched).\n \nWith the change to dynamic SSDT extraction file names (above) and this change, it means you can take any SSDT that was extracted, patch it, and place in ACPI/patched, and without making changes to DropOem or DropTables (or using SortedOrder) it will replace the original SSDT with the patched version, retaining SSDT order.  In other words, Clover does the right thing with AutoMerge=true, contrary to what it does by default.\n \nThis setting also affects how config.plist/ACPI/DSDT/Patches are treated.  Normally, such patches do not apply to SSDTs.  But with AutoMerge=true, such patches are now applied to patched OEM SSDTs in ACPI/patched.  Still, add-on SSDTs (eg. those that didn't match existing tables in XSDT), are not affected by ACPI/DSDT/Patches.  It means that no major surprises happen when you place a patched SSDTs in ACPI/patched.\n \nThe default of AutoMerge is false, so it is a feature you must explicitly select.<array>\n    <string>toBeDisabled.aml</string>\n    <string>toBeDisabled2.aml</string>\n    ...\n</array>"; ObjectID = "fYz-Cp-2LJ"; */
"fYz-Cp-2LJ.ibShadowedToolTip" = "Если TRUE, то Clover заменят таблицы, наденные в BIOS таблицами, лежащими в ACPI\patched (с одинаковым названием), даже если данная таблица не прописана в DropTables. Также теперь патчи DSDT применяются и к SSDT лежащим в ACPI\patched";

/* Class = "NSButton"; ibShadowedToolTip = "New way to patch an IntelGFX device."; ObjectID = "gaI-9R-Lhu"; */
"gaI-9R-Lhu.ibShadowedToolTip" = "Новый способ патчить устройство IntelGFX";

/* Class = "NSButton"; ibShadowedToolTip = "<key>EnableC4</key>\n<true/>\nThis key allows you to enable the C4 states generator. Disabled by default."; ObjectID = "hkD-Lc-e2c"; */
"hkD-Lc-e2c.ibShadowedToolTip" = "Включает генерацию C4 States.";

/* Class = "NSButton"; ibShadowedToolTip = "Fix non-ascii characters in ACPI tables headers."; ObjectID = "hSy-Jr-ymP"; */
"hSy-Jr-ymP.ibShadowedToolTip" = "Исправляет не-ASCII буквы в заголовках таблиц ACPI.";

/* Class = "NSButton"; ibShadowedToolTip = "Enable or disable fix on MCFG table, disabled by default."; ObjectID = "hTw-Km-4Vm"; */
"hTw-Km-4Vm.ibShadowedToolTip" = "Включает патч для таблицы MCFG.";

/* Class = "NSButton"; ibShadowedToolTip = "If you see in system log:\n\nAppleLPC::notifyPlatformASPM - registering with plugin with ASPM Support false\n\nThe message will gone and macOS works smoother.\nWhy? This is FADT->Flags bit 4.\nIf set, indicates to OSPM that it must not enable OSPM ASPM control on this platform.\nYes, macOS can't control hackintosh hardware ASPM. (OSPM = OS Power Management)"; ObjectID = "iCt-FQ-aaj"; */
"iCt-FQ-aaj.ibShadowedToolTip" = "Если при загрузке системы вы видите:   AppleLPC::notifyPlatformASPM - registering with plugin with ASPM Support false то включайте данный патч. Сообщение исчезнет, система станет работать плавнее.";

/* Class = "NSButton"; ibShadowedToolTip = "Injects the DeviceID from ICH6 to prevent the orange icons problem. \nNowadays this patch looks to be obsolete. \nIt is better to do the kext binary patch instead."; ObjectID = "jcL-Td-68d"; */
"jcL-Td-68d.ibShadowedToolTip" = "Исправляет желтые иконки, но сейчас лучше воспользоваться патчем кекста.";

/* Class = "NSButton"; ibShadowedToolTip = "Adds device MCHC to DSDT. For H61M this is obligatory, else KP."; ObjectID = "Jds-ye-0B2"; */
"Jds-ye-0B2.ibShadowedToolTip" = "Добавляет MCHC в DSDT. Для H61M это обязательно, иначе паника ядра.";

/* Class = "NSTextField"; ibShadowedToolTip = "<key>ResetAddress</key>\n<string>0x0CF9</string>\n\nand the below\n\n<key>ResetValue</key>\n<string>0x06</string>\n\n\nThese two parameters serve a very important purpose: to fix restart. \nThese values theoretically should be in the FADT table, but it is not always the case. \nFurthermore, FADT may be shorter than required and not contain them at all. \nDefault values are 0x64/0xFE, which means a restart through the PS2 controller.\nHowever, this does not work on every system and you can alternatively use 0x0CF9/0x06, \nwhich indicates a restart though the PCI rail. \nThis is the default value for real Macs but does not always work on a hackintosh. \nThe difference is clear: a hackintosh additionally has a PS2 controller, \nwhich may prevent rebooting, if not disabled.\nLast but not least you can set them to 0x0/0x0 to allow the use of default FACP values. \nIf not present, the default values states above will be used instead."; ObjectID = "Jga-JJ-yis"; */
"Jga-JJ-yis.ibShadowedToolTip" = "<key>ResetAddress</key>\n\
       <string>0x64</string>\n\
<key>ResetValue</key>\n\
       <string>0xFE</string>\n\
Эти два параметра служат для одного очень ценного фикса – исправление рестарта. Эти значения должны быть в таблице FADT, но почему-то они там не всегда есть, более того, бывает и сама таблица короче необходимого, короче настолько, что эти значения оказались отброшены. По умолчанию идет значение, уже присутствующее в FACP, однако, если там ничего нет, то используется пара 0x64/0xFE, что означает рестарт через PS2 контроллер. Практика показала, что это не у всех работает, другая возможная пара значений 0x0CF9/0x06, что означает рестарт через PCI шину. Эта пара используется и на нативнике, но не всегда работает на хакинтошах. Разница понятна, на хакинтошах есть еще и PS2 контроллер, который может помешать рестарту, если его не сбросить. Еще вариант 0x92/0x01, может кому-то поможет.";

/* Class = "NSComboBox"; ibShadowedToolTip = "<key>PLimitDict</key>\n<string>1</string>\nLimits the maximal CPU frequency.\n\n0 - No limit.\n1 - Reduce frequency by one step\n2 - Reduce frequency by two steps\nExample: A Core2Duo T8300 with 2400 MHz operates at a maximal frequency of 2000 MHz when limited by two steps. This parameter might be used to reduce heat in mobile systems.\n\nThe same parameter exists in platform plists, for example in: System/Library/Extensions/IOPlaEormPluginFamily.kext/Contents/PlugIns/ACPI_SMC_PlaEormPlugin.kext/Conte nts/Resources/MacBook5_1.plist.\nThey will be discussed later.\n\nOther CPUs may need other values. This value has a reversed effect on a Core2Quad for instance. The optimal value is 1 in this case. It may be a DSDT error, though."; ObjectID = "jwH-TR-qrW"; */
"jwH-TR-qrW.ibShadowedToolTip" = "<key>PLimitDict</key>\n\
             <string>1</string>\n\
Суть параметра очень проста – ограничить максимальную частоту процессора. Значение 0 – работа до максимума, 1 – на одну ступень меньше максимума, 2 – на две ступени. Пример: Core2Duo T8300 2400MHz работает на максимальной частоте 2000, если ограничить на две ступени. Зачем? Да чтобы ноутбук не перегревался, там возможности ЦПУ намного превышают возможности по охлаждению. Точно такой же параметр присутствует в платформ-плистах, например:\n\
System/Library/Extensions/IOPla ormPluginFamily.kext/Contents/PlugIns/ACPI_SMC_Pla ormPlugin.kext/Contents/ Resources/MacBook5_1.plist\n\
Для некоторых процессоров, например Core2Quad, замечено, что PlimitDict работает наоборот, и лучший вариант =1.";

/* Class = "NSButton"; ibShadowedToolTip = "Patch for the FATD table to fix restart problems."; ObjectID = "Klz-ag-dZN"; */
"Klz-ag-dZN.ibShadowedToolTip" = "Патч для таблицы FADT для исправления проблем с перезагрузкой";

/* Class = "NSButton"; ibShadowedToolTip = "Adds Return(Package(0)) into method _WAK if absent. \nThis patch eliminates a warning, but we don't know if it \naffects anything else on a working system."; ObjectID = "KQC-r6-auD"; */
"KQC-r6-auD.ibShadowedToolTip" = "Добавляет Return(Package(0)) в метод _WAK, если отсутствует. Этот патч убирает предупреждение, но мы не знаем, влияет ли он на работающую систему.";

/* Class = "NSButton"; ibShadowedToolTip = "Injects device and properties for the LAN controller.\nAlso made FakeID for some known substitutions."; ObjectID = "KqL-hQ-cAE"; */
"KqL-hQ-cAE.ibShadowedToolTip" = "Инжектирует свойства для LAN. Позволяет работать подмене ID.";

/* Class = "NSButton"; ibShadowedToolTip = "Adds IRQ(0, 8, 11) to device HPET. Obligatory for OSX <= 10.8,\nMavericks can work without it."; ObjectID = "Lel-Vs-BsK"; */
"Lel-Vs-BsK.ibShadowedToolTip" = "Добавляет IRQ(0,8,11) в устройство HPET. Важно для систем 10.8 и ниже, на 10.9 и выше особой роли не играет.";

/* Class = "NSButton"; ibShadowedToolTip = "Inserts APLF to CpuPm SSDT"; ObjectID = "Ljr-1u-hzE"; */
"Ljr-1u-hzE.ibShadowedToolTip" = "Добавляет APLF в SSDT с CpuPm";

/* Class = "NSButton"; ibShadowedToolTip = "Changes the device-id for the LPC chipset device. \nNeeded in very rare cases for non-standard (for Apple) chipsets, like ICH9."; ObjectID = "lTv-ds-RYE"; */
"lTv-ds-RYE.ibShadowedToolTip" = "Меняет ID устройства для LPC (чипсет). Требуется в редких случаях, когда чипсет нестандартный для Apple.";

/* Class = "NSButton"; ibShadowedToolTip = "Adds SMBUS device into DSDT, with some sub-device. \nI don't know the reason for the patch but it's advised in many forums. \nNever seen any problem with this bit."; ObjectID = "LV7-fj-m5P"; */
"LV7-fj-m5P.ibShadowedToolTip" = "Добавляет устройство SBUS в DSDT с некоторыми подустройствами.";

/* Class = "NSButton"; ibShadowedToolTip = "<key>Debug</key>\n<true/>\n\nEnable the debug logs of DSDT section."; ObjectID = "mcq-U0-L7F"; */
"mcq-U0-L7F.ibShadowedToolTip" = "Включает отладочные записи секции DSDT";

/* Class = "NSComboBox"; ibShadowedToolTip = "<key>UnderVoltStep</key>\n<string>1</string>\nThis parameter lowers the CPU voltage and indirectly affects the temperature. Possible values are 0, 1, 2, etc. Clover will only allow sane values, meaning it is safe to increase this value until the CPU stops working correctly."; ObjectID = "MDY-R1-Hlx"; */
"MDY-R1-Hlx.ibShadowedToolTip" = "Дополнительный параметр для снижения температуры процессора путем снижения его рабочего напряжения. Возможные значения 0, 1, 2, 3 ... чем больше, тем сильнее охлаждаем, пока компьютер не повиснет. Кловер не позволит поставить значение вне допустимого диапазона, вернее пишите, что хотите, а работать будет только то, что дозволено.";

/* Class = "NSButton"; ibShadowedToolTip = "<key>DropOEM_DSM</key>\n<true/>\nSome OEM DSDT already contains Method(_DSM...) for some devices. It has another structure, another logic, and another results then we need. But we can't modify this method, and we can't create own method with the same name, so DropOEM_DSM was created to drop these OEM _DSM.\n\nDefault value is false if using a custom DSDT and true if using BIOS.aml.\n\nAlternatively if you only need to drop the _DSM for certain devices, you can select any of these individually:\n\n<key>DropOEM_DSM</key>\n<dict>\n\t<key>ATI</key>\n\t<true/>\n\t<key>Firewire</key>\n\t<true/>\n\t<key>HDA</key>\n\t<true/>\n\t<key>HDMI</key>\n\t<true/>\n\t<key>IDE</key>\n\t<true/>\n\t<key>IntelGFX</key>\n\t<true/>\n\t<key>LAN</key>\n\t<true/>\n\t<key>LPC</key>\n\t<true/>\n\t<key>NVidia</key>\n\t<true/>\n\t<key>SATA</key>\n\t<true/>\n\t<key>SmBUS</key>\n\t<true/>\n\t<key>USB</key>\n\t<true/>\n\t<key>WIFI</key>\n\t<true/>\n</dict>"; ObjectID = "N1p-Js-JqA"; */
"N1p-Js-JqA.ibShadowedToolTip" = "В некоторых случаях устройство, которые мы хотим автоматически пропатчить, уже имеет ОЕМный метод _DSM. Дублировать нельзя, поэтому два варианта:\n\
<true/> - оригинальный метод будет откинут, и вместо него сгенерен наш,\n\
<false/> - встретив оригинальный метод мы ретируемся, ничего не сделав.\n\
Что там, в оригинальном методе? Да вряд ли то, что мы хотели бы увидеть, и вряд ли то, что нужно для OSX. Обычно производители БИОСов думают только о Windows.";

/* Class = "CocoaBindingsConnection"; ibShadowedIsNilPlaceholder = "hex or number"; ObjectID = "nRn-bw-I6o"; */
"nRn-bw-I6o.ibShadowedIsNilPlaceholder" = "HEX-код или число";

/* Class = "NSTextField"; ibShadowedToolTip = "<key>C3Latency</key>\n<integer>250</integer>\n\nor also\n\n<key>C3Latency</key>\n<string>0xFA</string>\n\nC3 states latency. You know what to do.. value above is for example."; ObjectID = "NUp-0c-FOE"; */
"NUp-0c-FOE.ibShadowedToolTip" = "Информация по параметру есть во вкладке CPU.";

/* Class = "NSTextField"; ibShadowedToolTip = "<key>ResetValue</key>\n<string>0x06</string>\n\nand the below\n\n<key>ResetAddress</key>\n<string>0x0CF9</string>\n\n\nThese two parameters serve a very important purpose: to fix restart. \nThese values theoretically should be in the FADT table, but it is not always the case. \nFurthermore, FADT may be shorter than required and not contain them at all. \nDefault values are 0x64/0xFE, which means a restart through the PS2 controller.\nHowever, this does not work on every system and you can alternatively use 0x0CF9/0x06, \nwhich indicates a restart though the PCI rail. \nThis is the default value for real Macs but does not always work on a hackintosh. \nThe difference is clear: a hackintosh additionally has a PS2 controller, \nwhich may prevent rebooting, if not disabled.\nLast but not least you can set them to 0x0/0x0 to allow the use of default FACP values. \nIf not present, the default values states above will be used instead."; ObjectID = "NVX-g4-ytQ"; */
"NVX-g4-ytQ.ibShadowedToolTip" = "<key>ResetAddress</key>\n\
       <string>0x64</string>\n\
<key>ResetValue</key>\n\
       <string>0xFE</string>\n\
Эти два параметра служат для одного очень ценного фикса – исправление рестарта. Эти значения должны быть в таблице FADT, но почему-то они там не всегда есть, более того, бывает и сама таблица короче необходимого, короче настолько, что эти значения оказались отброшены. По умолчанию идет значение, уже присутствующее в FACP, однако, если там ничего нет, то используется пара 0x64/0xFE, что означает рестарт через PS2 контроллер. Практика показала, что это не у всех работает, другая возможная пара значений 0x0CF9/0x06, что означает рестарт через PCI шину. Эта пара используется и на нативнике, но не всегда работает на хакинтошах. Разница понятна, на хакинтошах есть еще и PS2 контроллер, который может помешать рестарту, если его не сбросить. Еще вариант 0x92/0x01, может кому-то поможет.";

/* Class = "NSTextField"; ibShadowedToolTip = "<key>MinMultiplier</key>\n<integer>7</integer>\nMinimal CPU multiplier. Usually a value of 16 is ported, resulting in a frequency of 1600 MHz but you should use lower values when using SpeedStep, like 8 or even 7."; ObjectID = "O2a-KC-DUs"; */
"O2a-KC-DUs.ibShadowedToolTip" = "<key>MinMultiplier</key>\n\
             <integer>7</integer>\n\
Минимальный множитель процессора. Сам он рапортует, что 16, и предпочитает работать на частоте 1600, однако, для спидстепа следует задать в таблице стейты вниз до 800 или даже 700.";

/* Class = "NSTextField"; ibShadowedToolTip = "<key>Name</key>\n<string>DSDT.aml</string>\n\nFile name of the binary DSDT file to load and inject."; ObjectID = "O7A-vf-aOw"; */
"O7A-vf-aOw.ibShadowedToolTip" = "Имя файла DSDT для загрузки";

/* Class = "NSButton"; ibShadowedToolTip = "This parameter affects the power profile, which will be written into table FADT.\n\nValue|Type|Power supply type :---|:---|:--- 1|Desktop|AC 2|Mobile|Battery 3|Server|SmartUPS\n\nClover will choose between 1 and 2 according to the mobility bit \nand according to the Mobile parameter in SMBIOS. \nIt is, for example, possible to fake a mobile MacMini. \nValue 3 will be chosen if this parameter is enabled."; ObjectID = "oer-mY-NZs"; */
"oer-mY-NZs.ibShadowedToolTip" = "<key>smartUPS</key>\n\
<false/>\n\
Вообще-то, этот параметр предназначен для того, чтобы прописать в таблице FADT профиль питания=3. Логика следующая:\n\
PM=1 – desktop , питание от сети\n\
PM=2 – notebook, питание от сети или от батарейки\n\
PM=3 – server, питание от SmartUPS, про который MacOSX тоже что-то знает.\n\
Выбор между 1 и 2 Кловер сделает на основе анализа бита мобильности, но также есть и параметр Mobile в секции SMBIOS. Можно, к примеру, сказать, что у нас МакМини, и что он мобильный. Значение же 3 будет подставлено, если smartUPS=Yes.";

/* Class = "NSButton"; ibShadowedToolTip = "Adds initialization for IDE controllers (not SATA) to prevent panic with it."; ObjectID = "oh7-T6-pIG"; */
"oh7-T6-pIG.ibShadowedToolTip" = "Добавляет инициализацию IDE контроллера, чтобы предотвратить панику.";

/* Class = "NSTableView"; ibShadowedToolTip = "<key>DropTables</key>\n<array>\n  <dict>\n    <key>Signature</key>\n    <string>SSDT</string>\n    <key>TableId</key>\n    <string>SataTabl</string>\n  </dict>\n  <dict>\n    <key>Signature</key>\n    <string>SSDT</string>\n    <key>TableId</key>\n    <string>SataAddr</string>\n  </dict>\n  <dict>\n    <key>Signature</key>\n    <string>BGRT</string>\n  </dict>\n  <dict>\n    <key>TableId</key>\n    <string>A M I</string> (WARNING: DO NOT DO THIS!!!!!!!)\n  </dict>\n  ...\n</array>\nDrop OEM ACPI tables by signature and/or table identifier.\n\nAdditionally, now you can drop tables by their length. Why? Because we found Acer laptop where all SSDT have the same TableID.\n\n<key>DropTables</key>\n<array>\n  <dict>\n    <key>Signature</key>\n    <string>SSDT</string>\n    <key>Length</key>\n    <integer>720</integer>\n  </dict>\n</array>"; ObjectID = "OLn-tS-JOF"; */
"OLn-tS-JOF.ibShadowedToolTip" = "<key>DropTables</key>\n<array>\n  <dict>\n    <key>Signature</key>\n    <string>SSDT</string>\n    <key>TableId</key>\n    <string>SataTabl</string>\n  </dict>\n  <dict>\n    <key>Signature</key>\n    <string>SSDT</string>\n    <key>TableId</key>\n    <string>SataAddr</string>\n  </dict>\n  <dict>\n    <key>Signature</key>\n    <string>BGRT</string>\n  </dict>\n  <dict>\n    <key>TableId</key>\n    <string>A M I</string> (WARNING: DO NOT DO THIS!!!!!!!)\n  </dict>\n  ...\n</array>\n\
В этом массиве мы перечисляем таблицы, которые хотим отбросить. Иногда может потребоваться отбросить таблицы по длине, если название совпадает.";

/* Class = "NSTableView"; ibShadowedToolTip = "May you need to load your acpi tables in a certain order after\ndropping, load, disable.. some of it."; ObjectID = "OtX-jG-4Xq"; */
"OtX-jG-4Xq.ibShadowedToolTip" = "Вам может потребоваться загружать таблицы в определенном порядке...";

/* Class = "NSTableView"; ibShadowedToolTip = "Disable the specified aml table."; ObjectID = "QNa-bM-Ygz"; */
"QNa-bM-Ygz.ibShadowedToolTip" = "Выключает определенные таблицы";

/* Class = "NSButton"; ibShadowedToolTip = "Adds device Firewire into DSDT if absent and if the device really present. \nSafe."; ObjectID = "Rc4-tj-8Rc"; */
"Rc4-tj-8Rc.ibShadowedToolTip" = "Добавляет устройство Firewire в DSDT если там его нет, а физически присутствует";

/* Class = "NSBox"; ibShadowedToolTip = "<key>SSDT</key>\n<dict>\n...\n</dict>\nParameter group affecting SSDTs."; ObjectID = "RCR-Ih-qYY"; */
"RCR-Ih-qYY.ibShadowedToolTip" = "Группа параметров для правки SSDT.";

/* Class = "NSButton"; ibShadowedToolTip = "Some systems can either be started using the kernel parameter cpus=1, \nor by using a patched kernel (Lapic NMI). \nIt turns out that in these case the table MADT is incomplete and missing the NMI section. \nEnabling this parameter will cause Clover to automatically correct this table. \nIf the table already is complete, then nothing will be changed."; ObjectID = "RTx-HB-nsm"; */
"RTx-HB-nsm.ibShadowedToolTip" = "На некоторых компьютерах можно загрузить систему только с cpus=1, либо со специальным патченным ядром (Lapic NMI patch). Простейший анализ показал, что у них неправильная таблица MADT, а именно, в ней отсутствуют разделы NMI. Этот параметр служит для корректировки таких таблиц на лету.";

/* Class = "NSButton"; ibShadowedToolTip = "<key>AddDTGP</key>\n<true/>\n\nInserts Method (DTGP) into DSDT. It is required for _DSM methods, \nso if you use some other DSDT fix to inject device properties \nthen you must enable this. \nNo sense to use this method without other fixes."; ObjectID = "RzO-D2-a3y"; */
"RzO-D2-a3y.ibShadowedToolTip" = "Для описания свойств устройства, кроме варианта DeviceProperties, рассмотренном выше, есть вариант с методом _DSM, прописанным в DSDT.\n\
_DSM - Device Specific Method – хорошо известна заготовка этого метода, который работает в MacOSX начиная в версии 10.5, этот метод содержит массив с описанием устройства и вызов универсального метода DTGP, который един для всех устройств.\n\
Данный фикс просто добавляет этот метод, чтобы потом его применять для других фиксов.";

/* Class = "NSComboBox"; ibShadowedToolTip = "Changes the type of power management plugin your system will use. \nPossible values are: \n\n* 0 - ACPI_SMC_PlatformPlugin will be used \n* 1 - X86PlatformPlugin will be used. Select for Ivy Bridge +"; ObjectID = "Rzw-9e-3NX"; */
"Rzw-9e-3NX.ibShadowedToolTip" = "Выбирает тип управления питанием. Для IvyBridge и выше – 1, для остальных – 0.";

/* Class = "NSButton"; ibShadowedToolTip = "Inserts APSN to CpuPm SSDT"; ObjectID = "sDY-89-f8k"; */
"sDY-89-f8k.ibShadowedToolTip" = "Добавляет APSN в SSDT с CpuPm";

/* Class = "NSButton"; ibShadowedToolTip = "<key>ReuseFFFF</key>\n<true>\nSome OEM DSDT contains some device with Name (_ADR, 0xFFFF). This is a big problem as I can convert it to ADR=0 and inject properties but this is dangerous patch, it may lead to panic on IOPCIFamily.kext. So this key is proposed which will convert this device to (ADR, 0) and reused for injection. (FakeID for example)"; ObjectID = "sgl-xT-Xbu"; */
"sgl-xT-Xbu.ibShadowedToolTip" = "В некоторых случаях попытка сделать патч дисплея упирается в наличие в оригинальном
ДСДТ устройства типа Device (PEGP)
{
Name (_ADR, 0xFFFF) Name (_SUN, One)
}
Ему можно поменять адрес на 0, но это не всегда работает. <true/> - пытаемся поменять адрес, <false/> - уходим и не пытаемся его патчить.";

/* Class = "NSButton"; ibShadowedToolTip = "Excludes IRQ(8) from TMR device. \nThis is an ancient DOS device and is not needed in modern computers."; ObjectID = "SvT-dN-vk7"; */
"SvT-dN-vk7.ibShadowedToolTip" = "Исключает IRQ(8) из устройства TMR.";

/* Class = "NSTableView"; ibShadowedToolTip = "More exact renaming Devices in DSDT and SSDT taking into account its bridge.\nExample: \n<key>ACPI</key>\n\t<dict>\n\t\t<key>RenameDevices</key>\n\t\t<dict>\n\t\t\t<key>_SB.PCI0.RP02.PSXS</key>\n\t\t\t<string>ARPT</string>\n\t\t\t<key>_SB.PCI0.EHC1</key>\n\t\t\t<string>EH01</string>\n\t\t\t<key>_SB.PCI0.POP2.PEGP</key>\n\t\t\t<string>GFX0</string>\n\t\t</dict>\nComplex case such as this DSDT is also taken into account.\nExample:\n_SB.PCI0.RP02.PSXS\nWe have to take into account fields like\nScope(\\_SB)\n{\n  Device (PCI0)\n  {\n    Device(RP02)\n    {\n      Device(PSXS)  <- to patch\n      {\n\t\tMethod(_ON)\n\t\t{\n\t\t}\n\t\tMethod(_OFF)\n\t\t{\n\t\t}\n\n\t  }\n\t  PSXS._ON() <- to patch\n\t}\n\tScope(RP02)\n\t{\n\t  PSXS._OFF() <- to patch\n\t}\n\tDevice(RP03)\n\t{\n\t  Device(PSXS) <- to not patch\n\t  {\n\t  }\n\t  PSXS._ON() <- to not patch\n\t}"; ObjectID = "sXu-RZ-a8b"; */
"sXu-RZ-a8b.ibShadowedToolTip" = "<key>_SB.PCI0.RP02.PSXS</key>
В отличие от бинарных патчей ACPI, которые, кстати, действуют не только на DSDT, но и на SSDT также, и родные, и загружаемые, этот метод служит заменой для патча типа Find->PXSX, Replace->ARPT. Но если в секции DSDT->Patches такая замена действует на всем пространстве, то в методе RenameDevices алгоритм будет выискивать только те девайсы, которые лежат на указанном бридже.
</dict>
<string>ARPT</string>
<key>_SB.PCI0.EHC1</key>
<string>EH01</string>
<key>_SB.PCI0.POP2.PEGP</key>
<string>GFX0</string>
Вот такой сложный пример для первой замены
Scope(\_SB)
{
  Device (PCI0)
  {
    Device(RP02)
    {
      Device(PSXS)  <- здесь менять
      {
               Method(_ON)
               {
               }
               Method(_OFF)
               {
}
Клевер цвета хаки. Версия 2.4k, ревизия 4871 Москва, 2019г
104
}
         PSXS._ON() <- здесь менять
       }
Scope(RP02)
       {
         PSXS._OFF() <- здесь менять
       }
       Device(RP03)
       {
         Device(PSXS) <- здесь не менять
         {
         }
         PSXS._ON() <- здесь не менять
}";

/* Class = "NSButton"; ibShadowedToolTip = "Some OperationRegions in Bios DSDT are floating and values \nmay change in time due to changes in the BIOS. \nThe presence of floating regions makes it impossible \nto use a custom DSDT because this region may be shifted \nand will not correspond to the current state. \nThis patch is intended to find all such regions in BIOS and correct them in custom DSDT."; ObjectID = "TDb-hX-ayw"; */
"TDb-hX-ayw.ibShadowedToolTip" = "А вот это совершенно особый патч. Если остальные патчи предназначались для правки BIOS.aml, для создания хорошего DSDT из ничего, то данный фикс предназначен для окончательной юстировки хорошо сделанного кастомного DSDT.aml, и для BIOS.aml он бесполезен. Дело вот в чем.
В ДСДТ есть регионы, которые имеют свои адреса, например:
OperationRegion (GNVS, SystemMemory, 0xDE6A5E18, 0x01CD)
Проблема в том, что адрес этого региона создается БИОСом динамически, и он может быть различным от загрузки к загрузке. В первую очередь это было замечено при изменении общего количества памяти, затем при изменении настроек БИОСа, а на моем компьютере зависит даже от предыстории загрузок, например от объема занятого NVRAM. Понятно, что в кастомном DSDT.aml это число фиксированное, а значит, может не соответствовать истине. Самое простое наблюдение - отсутствие сна. После исправления региона сон появляется, но до следующего смещения.";

/* Class = "NSButton"; ibShadowedToolTip = "Adds If(arg=5){} to method _PTS. \nThis trick may repair shutdown problems for some systems (like ASUS)."; ObjectID = "Tui-lw-gUI"; */
"Tui-lw-gUI.ibShadowedToolTip" = "В функцию _PTS добавляется условие: если аргумент = 5 (выключение), то никаких других действий делать не надо.  Помогает для некоторых систем (как ASUS)";

/* Class = "NSButton"; ibShadowedToolTip = "The ACPI runtime in macOS/OS X does not work correctly with Mutex objects with a non-zero SyncLevel, even when used in a valid scenario.\nSuch Mutex definions must be changed to use SyncLevel 0.\nThe FixMutex feature is an easy way to fix all of them in DSDT."; ObjectID = "TxV-JD-sjp"; */
"TxV-JD-sjp.ibShadowedToolTip" = "OS X некорректно работает с объектами Mutex с уровнем синхронизации, на равным нулю, включите, чтобы исправить.";

/* Class = "NSButton"; ibShadowedToolTip = "Adds the HDAU device if absent, with some default properties."; ObjectID = "Ue7-vJ-xDA"; */
"Ue7-vJ-xDA.ibShadowedToolTip" = "Добавить устройство HDAU если отсутствует, со стандартными параметрами.";

/* Class = "NSBox"; ibShadowedToolTip = "Generate an SSDT with p-states and c-states."; ObjectID = "UWH-j3-WaF"; */
"UWH-j3-WaF.ibShadowedToolTip" = "Генерирует SSDT с C- и P- States";

/* Class = "NSButton"; ibShadowedToolTip = "The device PNLF is necessary to have brightness control. \nThis patch is also a good influence for proper Sleep/Wake."; ObjectID = "UYl-1m-Lpa"; */
"UYl-1m-Lpa.ibShadowedToolTip" = "PHLF необходим для раюоты управления яркостью, также влияет на сон/пробуждение.";

/* Class = "NSButton"; ibShadowedToolTip = "Deletes devices like Floppy drive, \nLPT port and others from the DSDT."; ObjectID = "VoS-Bu-03Y"; */
"VoS-Bu-03Y.ibShadowedToolTip" = "Удалить неиспользуемые в OS X устройства.";

/* Class = "NSButton"; ibShadowedToolTip = "<key>NoOemTableId</key>\n<true/>\n\nTo disable OEM table ID on ACPI/orgin/SSDT file names"; ObjectID = "vwy-Cc-5SB"; */
"vwy-Cc-5SB.ibShadowedToolTip" = "Выключает ОЕМ имена таблиц SSDT.";

/* Class = "NSTextFieldCell"; placeholderString = "hex or number"; ObjectID = "W3Q-9f-gWQ"; */
"W3Q-9f-gWQ.placeholderString" = "HEX-код или число";

/* Class = "NSTableColumn"; headerCell.title = "Type/key"; ObjectID = "WtF-Ra-tyb"; */
"WtF-Ra-tyb.headerCell.title" = "Тип/значение";

/* Class = "NSTableColumn"; headerToolTip = "Type/key"; ObjectID = "WtF-Ra-tyb"; */
"WtF-Ra-tyb.headerToolTip" = "Тип/значение";

/* Class = "NSButton"; ibShadowedToolTip = "Also resolves some Sleep/Wake problems by correcting _S3D methods."; ObjectID = "wX2-H5-kub"; */
"wX2-H5-kub.ibShadowedToolTip" = "Может исправить некоторые проблемы со сном, корректирую метоты _S3D.";

/* Class = "NSButton"; ibShadowedToolTip = "<key>EnableC2</key>\n<true/>\nThis key allows you to enable the C2 states generator. Disabled by default."; ObjectID = "WzK-0m-RGZ"; */
"WzK-0m-RGZ.ibShadowedToolTip" = "Включить генерацию C2 States.";

/* Class = "NSButton"; ibShadowedToolTip = "Renames AZAL to HDEF or HDAU. Adds the HMDI device if absent. \nElse AppleHDA will not work. Adds the properties \"layout-id\", \n\"MaximumBootBeepVolume\" and \"PinConfigurations\"."; ObjectID = "xf1-lI-6p1"; */
"xf1-lI-6p1.ibShadowedToolTip" = "Переименовывает AZAL в HDEF или HDAU. Добавляет устройство HDMI если отсутствует. В противном случае AppleHDA не заработает.";

/* Class = "NSButton"; ibShadowedToolTip = "<key>EnableC6</key>\n<true/>\nThis key allows you to enable the C6 states generator."; ObjectID = "xYb-XE-RHK"; */
"xYb-XE-RHK.ibShadowedToolTip" = "Включает генератор C6 States";

/* Class = "NSButton"; ibShadowedToolTip = "<key>EnableC7</key>\n<true/>\nThis key allows you to enable the C7 states generator. Disabled by default."; ObjectID = "XZZ-cF-eTb"; */
"XZZ-cF-eTb.ibShadowedToolTip" = "Включает генератор C7 States";

/* Class = "NSButton"; ibShadowedToolTip = "<key>Generate</key>\n<dict>\n  <key>CStates</key>\n  <true/>\n</dict>\nAutomatic SSDT table generation, which extends the processor section with _CST methods for each core. _CST generation is affected by parameters EnableC2, EnableC4, EnableC6, EnableISS, C3Latency. There is no need to comment them as everything will work either way. Experiment by yourself.\nBesides, Clover already has obtained the processor type and core count.\nNot using this parameter will result in following error message: ACPI_SMC_PlatformPlugin::pushCPU_CSTData - _CST evaluation failed."; ObjectID = "YGh-aR-Qpu"; */
"YGh-aR-Qpu.ibShadowedToolTip" = "Автоматическая генерация таблицы SSDT с методами _CST, на генерацию влияют параметры Enable(C2, C4, C6, C7), C3Latency.";

/* Class = "NSButton"; ibShadowedToolTip = "Injects USB devices and their properties for USB-1, \nUSB-2 and USB-3. No reason not to use this bit."; ObjectID = "yqA-Z1-Xka"; */
"yqA-Z1-Xka.ibShadowedToolTip" = "Поправляет USB. Нет причин не активировать этот патч.";

/* Class = "NSMenuItem"; title = "List Of Patches"; ObjectID = "yqg-Tz-OBP"; */
"yqg-Tz-OBP.title" = "Список патчей";

/* Class = "NSTabView"; ibShadowedToolTip = "This parameter represents a whole set of DSDT patches \nwhich can be activated individually. "; ObjectID = "zlp-4F-eaR"; */
"zlp-4F-eaR.ibShadowedToolTip" = "Этот параметр показывает набор патчей для DSDT, каждый включается отдельно.";

/* Class = "NSButton"; ibShadowedToolTip = "Deletes IRQ(2) from device IPIC. Helps with a non working Power button."; ObjectID = "Znz-uO-BAw"; */
"Znz-uO-BAw.ibShadowedToolTip" = "Удаляет IRQ(2) из устройства IPIC. Помогает с неработающей кнопкной Power.";

/* Class = "NSButton"; ibShadowedToolTip = "Dynamic SSDTs confuse users and are amost never needed.  Added an option to config.plist to disable extraction of them via Clover F4 (default is false)."; ObjectID = "Zpr-zM-4bX"; */
"Zpr-zM-4bX.ibShadowedToolTip" = "Динамические SSDT практически всегда не нужны и пугают пользователей, включите, чтобы они не извлекались по нажатию F4.";

/* Class = "NSButton"; ibShadowedToolTip = "<key>Rtc8Allowed</key>\n<false>\nSome users claim that RTC length may be 8 bytes without CMOS reset, but others claim that the reset is still occurring. For those who wants len=8 it should be set to true. Default is false."; ObjectID = "ZUY-vA-984"; */
"ZUY-vA-984.ibShadowedToolTip" = "true — длина региона останется 8 байт, если была таковой,
false — будет поправлена на 2 байта, что более надежно предохраняет от сброса ЦМОС.
Как исследовал vit9696 длину региона нужно все-таки оставлять 8, потому что она нужна для сохранения ключа гибернации. А сам по себе фикс полезен. Ну а на десктопах гибернация не нужна, так что может подумать о сбросе ЦМОС.";

